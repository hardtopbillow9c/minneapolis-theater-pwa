<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minneapolis Theater - Live Shows & Events</title>
    <meta name="description" content="Your ultimate guide to live theater shows and events in Minneapolis">
    <meta name="theme-color" content="#1a1a1a"> {/* Dark theme color */}
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;900&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Neon Glam Dark Theme Palette */
            --bg-main: #0D0D0D; /* Matte Black / Very Dark Charcoal */
            --bg-card: #1A1A1A; /* Slightly lighter for cards */
            --bg-header-blurred: rgba(15, 15, 15, 0.7); /* Darker, blurred header */
            
            --text-primary: #EAEAEA;    /* Light Gray / Off-White */
            --text-secondary: #B0B0B0;  /* Medium Gray */
            --text-on-accent: #FFFFFF;

            --accent-neon: #FF00FF; /* Neon Magenta */
            --accent-neon-dark: #cc00cc;
            --accent-neon-light: #ff66ff;
            --accent-neon-glow: rgba(255, 0, 255, 0.4);
            --accent-neon-glow-strong: rgba(255, 0, 255, 0.6);

            /* API Specific Colors (can be neon-ified or kept for distinction) */
            --ticketmaster: #00AFFF; /* Neon Blue */
            --eventbrite: #FF8C00;   /* Neon Orange */
            
            --success: #00FF7F; /* Neon Green */
            --warning: #FFEE00; /* Neon Yellow */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            /* Subtle glitter/noise texture */
            background-image: 
                linear-gradient(45deg, rgba(255,255,255,0.01) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.01) 75%, rgba(255,255,255,0.01)),
                linear-gradient(45deg, rgba(255,255,255,0.01) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.01) 75%, rgba(255,255,255,0.01));
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--accent-neon);
            border-radius: 5px;
            box-shadow: 0 0 10px var(--accent-neon-glow);
        }

        /* Header */
        .app-header {
            background: var(--bg-header-blurred);
            backdrop-filter: blur(15px);
            padding: 1.25rem 1.5rem;
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid rgba(255, 0, 255, 0.2); /* Neon border */
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .app-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.7rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--accent-neon-light);
            text-shadow: 0 0 8px var(--accent-neon-glow);
        }
        .app-title svg {
            stroke: var(--accent-neon-light);
            filter: drop-shadow(0 0 5px var(--accent-neon-glow));
        }

        .api-status {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .api-indicator {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255,255,255, 0.05);
            border: 1px solid rgba(255,255,255, 0.1);
            color: var(--text-secondary);
        }
        .api-indicator.active .status-dot {
             animation: pulseNeonDot 1.5s ease-in-out infinite;
        }
        @keyframes pulseNeonDot {
            0%, 100% { box-shadow: 0 0 3px var(--accent-neon); opacity: 0.7; }
            50% { box-shadow: 0 0 8px var(--accent-neon); opacity: 1; }
        }
        .api-indicator.ticketmaster { color: var(--ticketmaster); border-color: var(--ticketmaster); }
        .api-indicator.eventbrite { color: var(--eventbrite); border-color: var(--eventbrite); }


        .header-actions { display: flex; gap: 0.75rem; align-items: center; }
        .header-btn {
            background: transparent;
            border: 1px solid var(--accent-neon);
            color: var(--accent-neon-light);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-shadow: 0 0 5px var(--accent-neon-glow);
            box-shadow: 0 0 8px var(--accent-neon-glow);
        }
        .header-btn:hover {
            background: var(--accent-neon);
            color: var(--bg-main); /* Dark text on hover */
            text-shadow: none;
            box-shadow: 0 0 15px var(--accent-neon-glow-strong), 0 0 20px var(--accent-neon);
            transform: translateY(-1px);
        }
        .header-btn svg { stroke: currentColor; }

        /* Hero Section */
        .hero-section {
            padding: 4rem 1.5rem 3rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        .hero-section::before { /* Subtle background glow for hero */
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 80%;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, var(--accent-neon-glow) 0%, transparent 70%);
            opacity: 0.3;
            z-index: -1;
        }

        .hero-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 3rem;
            font-weight: 700; 
            margin-bottom: 1rem;
            line-height: 1.2;
            color: var(--text-primary);
            text-shadow: 0 0 10px rgba(255,255,255,0.3), 0 0 20px var(--accent-neon-glow);
        }

        .hero-subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-weight: 400;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Live Data Dashboard */
        .live-dashboard {
            background: rgba(0,0,0,0.2); 
            padding: 2rem;
            margin: 2.5rem auto;
            max-width: 1400px;
            border-radius: 16px;
            border: 1px solid rgba(255, 0, 255, 0.2);
            box-shadow: 0 0 20px var(--accent-neon-glow);
            backdrop-filter: blur(5px);
        }

        .dashboard-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--accent-neon-light);
            text-align: center;
            text-shadow: 0 0 8px var(--accent-neon-glow);
        }

        .api-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
        }

        .api-stat {
            background: transparent;
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
        }

        .api-stat-value {
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent-neon);
            text-shadow: 0 0 10px var(--accent-neon-glow-strong);
        }

        .api-stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Filters - Compacted */
        .filters {
            background: var(--bg-header-blurred); 
            padding: 0.5rem 1.5rem; /* Reduced vertical padding */
            border-top: 1px solid rgba(255, 0, 255, 0.2);
            border-bottom: 1px solid rgba(255, 0, 255, 0.2);
            position: sticky;
            top: 77px; /* This value depends on the actual rendered height of your header */
            z-index: 90;
            backdrop-filter: blur(10px);
        }

        .filter-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 0.75rem; /* Slightly reduced gap */
            flex-wrap: wrap;
            align-items: center;
        }

        .search-box {
            flex: 1;
            min-width: 280px; /* Adjusted min-width if needed */
            padding: 0.4rem 1.25rem; /* Reduced vertical padding */
            background: rgba(255,255,255, 0.05);
            border: 1px solid rgba(255,255,255, 0.1);
            border-radius: 18px; /* Slightly smaller radius */
            color: var(--text-primary);
            font-size: 0.85rem; /* Slightly smaller font */
            transition: all 0.2s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--accent-neon);
            box-shadow: 0 0 10px var(--accent-neon-glow);
        }

        .filter-btn {
            padding: 0.35rem 1rem; /* Reduced padding */
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 18px; /* Slightly smaller radius */
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem; /* Slightly smaller font */
            font-weight: 500;
        }

        .filter-btn.active {
            background: var(--accent-neon);
            border-color: var(--accent-neon);
            color: var(--bg-main);
            font-weight: 600;
            box-shadow: 0 0 15px var(--accent-neon-glow-strong);
            text-shadow: none;
        }

        .filter-btn:hover:not(.active) {
            border-color: var(--accent-neon-light);
            color: var(--accent-neon-light);
            box-shadow: 0 0 8px var(--accent-neon-glow);
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 1.5rem;
            margin: 2.5rem auto;
            max-width: 1400px;
            padding: 0 1.5rem;
            flex-wrap: wrap;
        }

        .stat-item {
            flex: 1;
            min-width: 200px;
            background: var(--bg-card);
            border: 1px solid rgba(255, 0, 255, 0.2);
            padding: 1.5rem;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.1);
            position: relative;
        }

        .stat-number {
            font-family: 'Montserrat', sans-serif;
            font-size: 2.8rem;
            font-weight: 700;
            color: var(--accent-neon);
            text-shadow: 0 0 10px var(--accent-neon-glow-strong);
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 0.25rem;
            font-weight: 500;
        }

        /* Events Grid */
        .events-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(360px, 1fr));
            gap: 2rem; 
            max-width: 1400px;
            margin: 2.5rem auto;
            padding: 0 1.5rem;
        }

        .event-card {
            background: var(--bg-card);
            border-radius: 12px; 
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            border: 1px solid var(--accent-neon); 
            box-shadow: 0 0 15px var(--accent-neon-glow), inset 0 0 10px rgba(255,0,255,0.1);
        }
        .event-card::before, .event-card::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-color: var(--accent-neon);
            border-style: solid;
            opacity: 0.8;
            box-shadow: 0 0 8px var(--accent-neon-glow);
        }
        .event-card::before { 
            top: -1px; left: -1px;
            border-width: 3px 0 0 3px;
            border-top-left-radius: 12px;
        }
        .event-card::after { 
            bottom: -1px; right: -1px;
            border-width: 0 3px 3px 0;
            border-bottom-right-radius: 12px;
        }

        .event-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 10px 30px var(--accent-neon-glow-strong), inset 0 0 15px rgba(255,0,255,0.2);
            border-color: var(--accent-neon-light);
        }
        .event-card:hover::before, .event-card:hover::after {
            border-color: var(--accent-neon-light);
            box-shadow: 0 0 12px var(--accent-neon-glow-strong);
        }

        .event-image {
            width: 100%;
            height: 200px;
            position: relative;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            border-bottom: 1px solid rgba(255,0,255,0.3); 
        }

        .event-image.placeholder {
            background: linear-gradient(135deg, var(--accent-neon-dark) 0%, var(--bg-main) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5rem;
            color: var(--accent-neon);
            text-shadow: 0 0 10px var(--accent-neon-glow-strong);
        }

        .event-badges {
            position: absolute;
            top: 0.75rem;
            left: 0.75rem;
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            z-index: 2;
        }

        .badge {
            background: rgba(15,15,15,0.7); 
            backdrop-filter: blur(5px);
            color: var(--text-secondary);
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .badge.ticketmaster { background: var(--ticketmaster); color: #000; border: none; }
        .badge.eventbrite { background: var(--eventbrite); color: #000; border: none; }
        .badge.local_listing { background: var(--accent-neon-light); color: var(--bg-main); border: none; }
        .badge.live {
            background: var(--success);
            color: var(--bg-main);
            border: none;
            animation: pulseLiveNeon 2s ease-in-out infinite;
        }
        @keyframes pulseLiveNeon {
            0%, 100% { opacity: 1; box-shadow: 0 0 5px var(--success); }
            50% { opacity: 0.7; box-shadow: 0 0 15px var(--success); }
        }
        
        .event-content { padding: 1.25rem; }
        .event-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.4rem; 
            font-weight: 600; 
            margin-bottom: 0.4rem;
            color: var(--text-primary);
            line-height: 1.3;
        }

        .event-theater {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-weight: 500;
        }
        .event-theater svg { stroke: var(--text-secondary); }

        .event-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
            padding: 0.75rem 0;
            border-top: 1px solid rgba(255,0,255,0.2);
            border-bottom: 1px solid rgba(255,0,255,0.2);
        }

        .event-date { font-size: 0.85rem; color: var(--text-secondary); }
        .event-price {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.2rem; 
            font-weight: 700;
            color: var(--accent-neon-light);
            text-shadow: 0 0 8px var(--accent-neon-glow);
        }

        .event-actions { display: flex; gap: 0.75rem; margin-top: 0.5rem;}
        .action-btn {
            flex: 1;
            padding: 0.7rem;
            background: rgba(255,0,255,0.1); 
            border: 1px solid var(--accent-neon);
            border-radius: 10px;
            color: var(--accent-neon-light);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            font-size: 0.85rem;
            font-weight: 500;
            box-shadow: 0 0 5px var(--accent-neon-glow);
        }
        .action-btn svg { stroke: currentColor; }
        .action-btn:hover {
            background: var(--accent-neon);
            border-color: var(--accent-neon-light);
            color: var(--bg-main);
            transform: translateY(-1px);
            box-shadow: 0 0 15px var(--accent-neon-glow-strong);
        }

        /* Loading */
        .loading { text-align: center; padding: 4rem; font-size: 1rem; color: var(--text-secondary); }
        .spinner {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid var(--accent-neon);
            border-radius: 50%;
            width: 50px; height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1.5rem;
            box-shadow: 0 0 10px var(--accent-neon-glow);
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 1.5rem; left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card); 
            color: var(--text-primary);
            padding: 1rem 2rem;
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5), 0 0 15px var(--accent-neon-glow);
            display: none;
            z-index: 1100;
            border: 1px solid var(--accent-neon);
            font-weight: 500; font-size: 0.9rem;
        }
        .toast.show { display: block; animation: toastSlide 0.3s ease; }
        @keyframes toastSlide { from { transform: translate(-50%, 80%); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }

        /* Responsive */
        @media (max-width: 768px) {
            .hero-title { font-size: 2.2rem; }
            .events-grid { grid-template-columns: 1fr; gap: 1.5rem; padding: 0 1rem; }
            .filter-container { flex-direction: column; gap: 0.75rem; }
            .search-box { width: 100%; }
            .api-status { width: 100%; justify-content: center; margin-top: 0.5rem; }
            .app-header { padding: 1rem; }
            .filters { top: 70px; /* Adjust if header height changed */ }
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div class="header-content">
            <div class="app-title">
                <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M22 16v-11a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v11h20z"/>
                    <path d="M2 16h20v4a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-4z"/>
                    <circle cx="8" cy="10" r="2"/>
                    <circle cx="16" cy="10" r="2"/>
                </svg>
                Minneapolis Theater
            </div>
            <div class="api-status">
                <div class="api-indicator ticketmaster" id="tmStatus">
                    <div class="status-dot" style="width: 8px; height: 8px; background: currentColor; border-radius: 50%;"></div>
                    Ticketmaster
                </div>
                <div class="api-indicator eventbrite" id="ebStatus">
                    <div class="status-dot" style="width: 8px; height: 8px; background: currentColor; border-radius: 50%;"></div>
                    Eventbrite
                </div>
            </div>
            <div class="header-actions">
                <button class="header-btn" id="refreshBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <polyline points="1 20 1 14 7 14"></polyline>
                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                    </svg>
                    Refresh Live Data
                </button>
                <button class="header-btn" id="installBtn" style="display: none;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Install
                </button>
            </div>
        </div>
    </header>

    <section class="hero-section">
        <h1 class="hero-title">Minneapolis Theater Live</h1>
        <p class="hero-subtitle">Your ultimate guide to live shows & events.</p>
    </section>

    <div class="live-dashboard" id="liveDashboard" style="display: none;">
        <h3 class="dashboard-title">Live Event Feed</h3>
        <div class="api-stats">
            <div class="api-stat">
                <div class="api-stat-value" id="tmCount">0</div>
                <div class="api-stat-label">Ticketmaster Events</div>
            </div>
            <div class="api-stat">
                <div class="api-stat-value" id="ebCount">0</div>
                <div class="api-stat-label">Eventbrite Events</div>
            </div>
            <div class="api-stat">
                <div class="api-stat-value" id="lastUpdate">Never</div>
                <div class="api-stat-label">Last Updated</div>
            </div>
        </div>
    </div>

    <div class="filters">
        <div class="filter-container">
            <input type="text" class="search-box" id="searchBox" placeholder="Search events, venues, artists...">
            <button class="filter-btn active" data-filter="all">All Events</button>
            <button class="filter-btn" data-filter="ticketmaster">Ticketmaster</button>
            <button class="filter-btn" data-filter="eventbrite">Eventbrite</button>
            <button class="filter-btn" data-filter="local_listing">Local Listings</button>
            <button class="filter-btn" data-filter="today">Today</button>
            <button class="filter-btn" data-filter="week">This Week</button>
        </div>
    </div>

    <main>
        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-number" id="totalShows">0</div>
                <div class="stat-label">Total Events</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="liveShows">0</div>
                <div class="stat-label">Via API</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="todayShows">0</div>
                <div class="stat-label">Today's Shows</div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            Summoning the Events...
        </div>
        <div class="events-grid" id="eventsGrid"></div>
    </main>

    <div class="toast" id="toast"></div>

    <script>
        // NOTE: The 'staticEventsData' array is intentionally empty here.
        // It will be populated by the fetchAndProcessStaticEvents function.
        const staticEventsData = []; 

        const API_CONFIG = {
            secure: true,
            functionsUrl: '/.netlify/functions/get-events' 
        };

        let allEvents = []; 
        let ticketmasterEvents = [];
        let eventbriteEvents = [];
        let currentFilter = 'all';
        let searchTerm = '';
        let lastUpdateTime = null;

        function parseCSV(csvText) {
            const lines = csvText.trim().split(/\r?\n/); 
            if (lines.length < 2) return []; 

            const headers = lines[0].split(',').map(header => header.trim());
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue; 
                const values = lines[i].split(',').map(value => value.trim());
                
                if (values.length === headers.length) {
                    const entry = {};
                    headers.forEach((header, index) => {
                        entry[header] = values[index];
                    });
                    data.push(entry);
                } else {
                    console.warn(`Skipping CSV line ${i+1} due to mismatched columns: ${lines[i]}`);
                }
            }
            return data;
        }

        async function fetchAndProcessStaticEvents(csvUrl) {
            let staticEventsFromCsv = []; 
            try {
                console.log('Attempting to fetch CSV from:', csvUrl);
                const response = await fetch(csvUrl);
                if (!response.ok) {
                    console.error(`Error fetching CSV: ${response.status} ${response.statusText} for URL: ${csvUrl}`);
                    showToast(`⚠️ Local CSV load error. Check console.`); 
                    return staticEventsFromCsv; 
                }
                const csvText = await response.text();
                const parsedCsvData = parseCSV(csvText);

                staticEventsFromCsv = parsedCsvData.map((row, index) => {
                    const eventNumber = row["No."] || row["No"] || (index + 1); 
                    const eventName = row["Event Name"] || 'Untitled Static Event';
                    const eventDates = row["Date(s)"] || 'Date TBD';
                    const eventTimes = row["Time(s)"] || 'Varies';
                    const venueName = row["Venue Name"] || 'Venue TBD';
                    const venueAddress = row["Venue Address/Area"] || 'Address TBD';
                    const category = row["Category"] || 'General';
                    const notes = row["Notes"] || '';

                    return {
                        id: `static_${eventNumber}`,
                        title: eventName,
                        dates: eventDates, 
                        times: eventTimes, 
                        theater: venueName,
                        address: venueAddress,
                        category: category,
                        description: notes, 
                        source: 'local_listing',
                        rawDate: parseCsvDateToIso(eventDates, eventTimes), 
                        genre: category, 
                        price: 'Varies', 
                        url: '#', 
                        image: null,
                        imageAlt: '🎭',
                        saleStatus: 'onsale' 
                    };
                });
                return staticEventsFromCsv;
            } catch (error) {
                console.error(`Error fetching or processing static events CSV from ${csvUrl}:`, error);
                showToast('⚠️ Error processing local CSV. Check console.'); 
                return staticEventsFromCsv; 
            }
        }

        function parseCsvDateToIso(dateStr, timeStr = "Varies") {
            if (!dateStr) return null;
            const currentYear = new Date().getFullYear(); 
            let year = currentYear;
            let monthStr, dayStr;

            const monthMap = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11 };

            const yearMatch = dateStr.match(/\b(\d{4})\b/);
            if (yearMatch) {
                year = parseInt(yearMatch[1]);
                dateStr = dateStr.replace(yearMatch[1], '').trim(); 
            }

            let rangeMatch = dateStr.match(/(\w+)\s*(\d+)\s*(?:-\s*(?:\w+\s*)?(\d+))?/i);
            if (rangeMatch) {
                monthStr = rangeMatch[1].toLowerCase().substring(0, 3);
                dayStr = rangeMatch[2];
            } else {
                let singleDateMatch = dateStr.match(/(\w+)\s*(\d+)/i);
                if (singleDateMatch) {
                    monthStr = singleDateMatch[1].toLowerCase().substring(0, 3);
                    dayStr = singleDateMatch[2];
                } else {
                    let monthOnlyMatch = dateStr.match(/(\w+)/i);
                    if (monthOnlyMatch) {
                        monthStr = monthOnlyMatch[1].toLowerCase().substring(0, 3);
                        dayStr = "1"; 
                    } else {
                        // console.warn("Could not parse date string for rawDate:", dateStr); // Less noisy
                        return null;
                    }
                }
            }
            
            const month = monthMap[monthStr];
            const day = parseInt(dayStr);

            if (month === undefined || isNaN(day)) {
                // console.warn("Could not parse month/day from:", dateStr); // Less noisy
                return null;
            }

            let hour = 12, minute = 0; 
            if (timeStr && timeStr.toLowerCase() !== "varies") {
                const timeMatch = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
                if (timeMatch) {
                    hour = parseInt(timeMatch[1]);
                    minute = parseInt(timeMatch[2]);
                    if (timeMatch[3] && timeMatch[3].toLowerCase() === 'pm' && hour < 12) {
                        hour += 12;
                    }
                    if (timeMatch[3] && timeMatch[3].toLowerCase() === 'am' && hour === 12) { 
                        hour = 0;
                    }
                }
            }
            try {
                return new Date(year, month, day, hour, minute).toISOString();
            } catch (e) {
                console.error("Error creating date object:", year, month, day, e);
                return null;
            }
        }
        
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(reg => console.log('ServiceWorker registered'))
                    .catch(err => console.log('ServiceWorker registration failed: ', err));
            });
        }

        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('installBtn').style.display = 'flex';
        });

        document.getElementById('installBtn').addEventListener('click', () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') { showToast('✨ App installed successfully!'); }
                    deferredPrompt = null;
                });
            }
        });

        async function fetchTicketmasterEvents() {
            const tmStatus = document.getElementById('tmStatus');
            tmStatus.classList.add('active');
            ticketmasterEvents = []; 
            let urlToFetch = '';
            try {
                if (!API_CONFIG.functionsUrl || typeof API_CONFIG.functionsUrl !== 'string' || !API_CONFIG.functionsUrl.startsWith('/')) {
                    console.error("Invalid API_CONFIG.functionsUrl for Ticketmaster:", API_CONFIG.functionsUrl);
                    showToast('⚠️ API configuration error. Check console.');
                    document.getElementById('tmCount').textContent = 'Config Error';
                    tmStatus.classList.remove('active');
                    return; 
                }
                urlToFetch = `${API_CONFIG.functionsUrl}?source=ticketmaster`;
                console.log("Attempting to fetch Ticketmaster from:", urlToFetch); 
                const response = await fetch(urlToFetch);
                if (!response.ok) { throw new Error(`HTTP ${response.status}`); }
                const data = await response.json();
                if (data._embedded && data._embedded.events) {
                    ticketmasterEvents = data._embedded.events.map(event => ({
                        id: `tm_${event.id}`, title: event.name,
                        theater: event._embedded.venues[0].name,
                        address: event._embedded.venues[0].address ? `${event._embedded.venues[0].address.line1}, ${event._embedded.venues[0].city.name}` : event._embedded.venues[0].city.name,
                        category: determineCategory(event), dates: formatTicketmasterDate(event.dates), price: formatTicketmasterPrice(event.priceRanges),
                        description: event.info || event.pleaseNote || `Don't miss ${event.name} live!`,
                        image: event.images?.sort((a, b) => b.width - a.width)[0]?.url || null,
                        imageAlt: '🎭', source: 'ticketmaster', url: event.url, saleStatus: event.dates.status.code, genre: event.classifications?.[0]?.genre?.name,
                        coordinates: event._embedded.venues[0].location ? { lat: parseFloat(event._embedded.venues[0].location.latitude), lng: parseFloat(event._embedded.venues[0].location.longitude) } : null,
                        rawDate: event.dates.start.dateTime || event.dates.start.localDate
                    }));
                    document.getElementById('tmCount').textContent = ticketmasterEvents.length;
                } else { 
                    document.getElementById('tmCount').textContent = '0'; 
                }
                tmStatus.classList.remove('active');
            } catch (error) {
                console.error(`Ticketmaster API Error for URL ${urlToFetch}:`, error); 
                showToast('⚠️ Ticketmaster API issue. Check console.'); 
                document.getElementById('tmCount').textContent = 'Error';
                tmStatus.classList.remove('active');
            }
        }

        async function fetchEventbriteEvents() {
            const ebStatus = document.getElementById('ebStatus');
            ebStatus.classList.add('active');
            eventbriteEvents = []; 
            let urlToFetch = '';
            try {
                if (!API_CONFIG.functionsUrl || typeof API_CONFIG.functionsUrl !== 'string' || !API_CONFIG.functionsUrl.startsWith('/')) {
                    console.error("Invalid API_CONFIG.functionsUrl for Eventbrite:", API_CONFIG.functionsUrl);
                    showToast('⚠️ API configuration error. Check console.');
                    document.getElementById('ebCount').textContent = 'Config Error';
                    ebStatus.classList.remove('active');
                    return; 
                }
                urlToFetch = `${API_CONFIG.functionsUrl}?source=eventbrite`;
                console.log("Attempting to fetch Eventbrite from:", urlToFetch); 
                const response = await fetch(urlToFetch);
                if (!response.ok) { throw new Error(`HTTP ${response.status}`); }
                const data = await response.json();
                if (data.events) {
                    eventbriteEvents = data.events.filter(event => event.venue && event.name.text).map(event => ({
                        id: `eb_${event.id}`, title: event.name.text,
                        theater: event.venue.name || 'Minneapolis Venue',
                        address: event.venue.address ? `${event.venue.address.address_1}, ${event.venue.address.city}` : 'Minneapolis, MN',
                        category: 'theater', dates: formatEventbriteDate(event.start, event.end), price: event.is_free ? 'Free' : formatEventbritePrice(event.ticket_availability),
                        description: event.description.text ? event.description.text.substring(0, 200) + '...' : `Experience ${event.name.text} live!`,
                        image: event.logo?.original?.url || null, imageAlt: '🎪', source: 'eventbrite', url: event.url, status: event.status,
                        coordinates: event.venue.latitude ? { lat: parseFloat(event.venue.latitude), lng: parseFloat(event.venue.longitude) } : null,
                        rawDate: event.start.utc
                    }));
                    document.getElementById('ebCount').textContent = eventbriteEvents.length;
                } else { 
                    document.getElementById('ebCount').textContent = '0'; 
                }
                ebStatus.classList.remove('active');
            } catch (error) {
                console.error(`Eventbrite API Error for URL ${urlToFetch}:`, error); 
                showToast('⚠️ Eventbrite API issue. Check console.'); 
                document.getElementById('ebCount').textContent = 'Error';
                ebStatus.classList.remove('active');
            }
        }
        
        function determineCategory(event) { 
            if (!event.classifications) return 'theater'; const c = event.classifications[0];
            if (c.segment?.name === 'Music') { return c.genre?.name?.includes('Musical') ? 'musical' : 'concert'; }
            if (c.genre?.name?.includes('Comedy')) return 'comedy'; if (c.genre?.name?.includes('Drama')) return 'drama';
            if (c.genre?.name?.includes('Dance')) return 'dance'; return 'theater';
        }
        function formatTicketmasterDate(dates) { 
            if (!dates.start) return 'TBA'; const start = new Date(dates.start.localDate);
            let fmt = start.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
            if (dates.start.localTime) { const [h, m] = dates.start.localTime.split(':'); const hr = parseInt(h);
                fmt += ` at ${hr % 12 || 12}:${m} ${hr >= 12 ? 'PM' : 'AM'}`; } return fmt;
        }
        function formatTicketmasterPrice(ranges) { 
            if (!ranges || ranges.length === 0) return 'See Tickets'; const r = ranges[0];
            const min = r.min || 0; const max = r.max || r.min || 0;
            if (min === max && min !== 0) return `$${Math.round(min)}`;
            if (min === 0 && max === 0 && r.type !== "noFee") return 'Potentially Free';
            if (min === 0 && max === 0 && r.type === "noFee") return 'Free';
            return `$${Math.round(min)}-$${Math.round(max)}`;
        }
        function formatEventbriteDate(start, end) { 
            const sd = new Date(start.local);
            return sd.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }) + ` ${sd.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}`;
        }
        function formatEventbritePrice(avail) { 
            if (!avail) return 'Check Website';
            if (avail.minimum_ticket_price && avail.maximum_ticket_price) {
                const min = avail.minimum_ticket_price.major_value; const max = avail.maximum_ticket_price.major_value;
                if (parseFloat(min) === parseFloat(max)) return `$${min}`; return `$${min}-$${max}`;
            } return 'See Tickets';
        }
        
        async function fetchAllLiveData() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('eventsGrid').innerHTML = '';
            document.getElementById('liveDashboard').style.display = 'block';

            const csvFileUrl = 'data/events.csv'; 
            const staticEventsFromCsv = await fetchAndProcessStaticEvents(csvFileUrl);

            let combinedEvents = [...staticEventsFromCsv]; 
            ticketmasterEvents = []; 
            eventbriteEvents = [];

            await Promise.all([
                fetchTicketmasterEvents(), 
                fetchEventbriteEvents()   
            ]);

            combinedEvents.push(...ticketmasterEvents);
            combinedEvents.push(...eventbriteEvents);
            
            combinedEvents.sort((a, b) => {
                if (!a.rawDate || !b.rawDate) return !a.rawDate ? 1 : -1;
                try {
                    const dateA = new Date(a.rawDate);
                    const dateB = new Date(b.rawDate);
                    if (isNaN(dateA.getTime())) return 1; 
                    if (isNaN(dateB.getTime())) return -1;
                    return dateA - dateB;
                } catch (e) { return 0; }
            });
            
            const uniqueEvents = [];
            const seenSignatures = new Set();
            for (const event of combinedEvents) {
                const title = event.title?.toLowerCase() || '';
                const datePart = event.rawDate ? String(event.rawDate).substring(0,10) : (event.dates?.substring(0,10) || 'nodate');
                const theater = event.theater?.toLowerCase() || '';
                const signature = `${title}|${datePart}|${theater}`;
                if (!seenSignatures.has(signature)) {
                    uniqueEvents.push(event);
                    seenSignatures.add(signature);
                }
            }
            allEvents = uniqueEvents; 
            
            lastUpdateTime = new Date();
            document.getElementById('lastUpdate').textContent = lastUpdateTime.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
            
            updateStats(); 
            renderEvents(); 
            
            document.getElementById('loading').style.display = 'none';
        }

        function updateStats() { 
            const total = allEvents.length;
            const live = allEvents.filter(e => e.source === 'ticketmaster' || e.source === 'eventbrite').length;
            const today = new Date(); 
            const todayStart = new Date(today.getFullYear(),today.getMonth(),today.getDate());
            const todayEvents = allEvents.filter(e => {
                if (!e.rawDate) return false;
                try {
                    const eventDate = new Date(e.rawDate);
                    return !isNaN(eventDate.getTime()) && eventDate >= todayStart && eventDate < new Date(todayStart.getTime()+24*60*60*1000);
                } catch (er) { return false; }
            }).length;
            document.getElementById('totalShows').textContent = total;
            document.getElementById('liveShows').textContent = live; 
            document.getElementById('todayShows').textContent = todayEvents;
        }

        function renderEvents() { 
            const grid = document.getElementById('eventsGrid'); let filtered = [...allEvents];
            const today = new Date(); const todayDateStr = today.toDateString();
            const weekFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);

            switch (currentFilter) {
                case 'ticketmaster': filtered = allEvents.filter(e => e.source === 'ticketmaster'); break;
                case 'eventbrite': filtered = allEvents.filter(e => e.source === 'eventbrite'); break;
                case 'local_listing': filtered = allEvents.filter(e => e.source === 'local_listing'); break;
                case 'today': 
                    filtered = allEvents.filter(e => {
                        if (!e.rawDate) return false;
                        try { return new Date(e.rawDate).toDateString() === todayDateStr; } catch(er){return false;}
                    }); 
                    break;
                case 'week': 
                    filtered = allEvents.filter(e => {
                        if (!e.rawDate) return false;
                        try { const eventD = new Date(e.rawDate); return !isNaN(eventD.getTime()) && eventD >= today && eventD <= weekFromNow; } catch(er){return false;}
                    }); 
                    break;
            }
            if (searchTerm) { const st = searchTerm.toLowerCase();
                filtered = filtered.filter(e => e.title?.toLowerCase().includes(st) || e.theater?.toLowerCase().includes(st) || e.description?.toLowerCase().includes(st) || e.genre?.toLowerCase().includes(st)); }
            
            if (filtered.length === 0) { grid.innerHTML = `<div class="loading" style="padding:2rem;font-size:0.9rem;color:var(--text-secondary);">No events match. Try refreshing or changing filters.</div>`; updateStats(); return; }
            
            grid.innerHTML = filtered.map(event => `
                <div class="event-card" onclick="if('${event.url}' && '${event.url}' !== '#') window.open('${event.url}', '_blank');" title="Click for details on ${event.source || 'listing'}">
                    <div class="event-image ${!event.image ? 'placeholder' : ''}" ${event.image ? `style="background-image: url('${event.image}');"` : ''}>
                        ${!event.image ? (event.imageAlt || '🎭') : ''}
                        <div class="event-badges">
                            <span class="badge ${event.source || 'local_listing'}">${(event.source || 'local_listing').replace('_', ' ')}</span>
                            ${(event.saleStatus === 'onsale' || event.status === 'live') ? '<span class="badge live">LIVE</span>' : ''}
                            ${event.genre ? `<span class="badge">${event.genre}</span>` : ''}
                        </div>
                    </div>
                    <div class="event-content">
                        <h3 class="event-title">${event.title || 'Untitled Event'}</h3>
                        <p class="event-theater"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="flex-shrink:0;"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>${event.theater || 'Venue TBD'}</p>
                        <div class="event-details"><span class="event-date">${event.dates || 'Date TBD'}</span><span class="event-price">${event.price || 'Details Online'}</span></div>
                        <div class="event-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); shareEvent('${event.title || ''}','${event.theater || ''}','${event.url || ''}')" title="Share Event"><svg width="14" height="14" viewBox="0 0 24 24"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>Share</button>
                            <button class="action-btn" title="View Details" ${(!event.url || event.url === '#') ? 'disabled style="opacity:0.5; cursor:default;"' : ''}><svg width="14" height="14" viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>Details</button>
                        </div>
                    </div>
                </div>`).join('');
            updateStats();
        }

        function shareEvent(title, theater, url) { 
            const shareUrl = (url && url !== '#') ? url : window.location.href;
            if (navigator.share) { navigator.share({ title: `${title} at ${theater}`, text: `Check out: ${title} at ${theater}`, url: shareUrl }).then(() => showToast('✨ Shared!')).catch(err=>showToast('Share failed.'));
            } else { navigator.clipboard.writeText(`${title} at ${theater} - ${shareUrl}`).then(() => showToast('📋 Link copied!')); }
        }
        function showToast(message) { 
            const toast = document.getElementById('toast'); toast.textContent = message; toast.className = 'toast show';
            setTimeout(() => { toast.className = 'toast'; }, 3000);
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('searchBox').addEventListener('input', (e) => { searchTerm = e.target.value; renderEvents(); });
            
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active'); currentFilter = btn.dataset.filter; renderEvents();
                });
            });

            document.getElementById('refreshBtn').addEventListener('click', () => { showToast('🔄 Refreshing data...'); fetchAllLiveData(); });
            
            console.log('Neon Glam Initialized with CSV Data Fetching!'); 
            fetchAllLiveData(); 
        });
        
        setInterval(() => { showToast('🔄 Auto-refreshing data...'); fetchAllLiveData(); }, 300000);
    </script>
</body>
</html>
